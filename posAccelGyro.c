#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    yAmtr,          sensorAccelerometer)
#pragma config(Motor,  port2,           frDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port3,           flDrive,       tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port8,           blDrive,       tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           brDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SAMPLE_SIZE 10

#define RX vexRT[Ch1]
#define RY vexRT[Ch2]
#define LY vexRT[Ch3]
#define LX vexRT[Ch4]

#define STICK_THRESH 7

float //xAccel[SAMPLE_SIZE],
	yAccel[SAMPLE_SIZE],
	deltaTheta[SAMPLE_SIZE],
	//xAccelAvg = 0,
	yAccelAvg = 0,
	deltaThetaAvg = 0,
	thetaLast = 0,
	//xVel = 0,
	yVel = 0,
	xPos = 0,
	yPos = 0,
	theta = 0,
	stickRX = 0,
	stickLY = 0;

void setRDrive(float pwr) {
	motor[frDrive] =
		motor[brDrive] =
		pwr;
}

void setLDrive(float pwr) {
	motor[flDrive] =
		motor[blDrive] =
		pwr;
}

void arcadeDrive(float x, float y) {
	setRDrive(y - x);
	setLDrive(y + x);
}

task main()
{
	for(int i = 0; i < SAMPLE_SIZE; i++) {
		//xAccel[i] = 0;
		yAccel[i] = 0;
		deltaTheta[i] = 0;
	}
	while(true) {
		for(int i = SAMPLE_SIZE - 1; i > 0; i--) {
			//xAccel[i] = xAccel[i-1];
			yAccel[i] = yAccel[i-1];
			deltaTheta[i] = deltaTheta[i-1];
		}

		//xAccel[0] = SensorValue[xAmtr];
		yAccel[0] = SensorValue[yAmtr];
		deltaTheta[0] = SensorValue[gyro] - thetaLast;
		thetaLast = SensorValue[gyro];
		if(fabs(deltaTheta[0]) < SensorBias[gyro])
			deltaTheta[0] = 0;

		//xAccelAvg =
			yAccelAvg =
			deltaThetaAvg =
			0;

		for(int a = 0; a < SAMPLE_SIZE; a++) {
			//xAccelAvg += xAccel[a];
			yAccelAvg += yAccel[a];
			deltaThetaAvg += deltaTheta[a];
		}

		//xAccelAvg /= SAMPLE_SIZE;
		yAccelAvg = yAccelAvg / SAMPLE_SIZE;
		deltaThetaAvg = deltaThetaAvg / SAMPLE_SIZE;

		//xVel += xAccelAvg;
		yVel += yAccelAvg;
		theta += deltaThetaAvg;

		xPos += sin(theta * PI / 180) * yVel;
		yPos += cos(theta * PI / 180) * yVel;

		if(fabs(LY) > STICK_THRESH)
			stickLY = LY;
		else
			stickLY = 0;
		if(fabs(RX) > STICK_THRESH)
			stickRX = RX;
		else
			stickRX = 0;

		arcadeDrive(stickRX, stickLY);

		wait1Msec(20);
	}
}
